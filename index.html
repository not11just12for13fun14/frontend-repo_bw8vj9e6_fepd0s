<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>DuraSim — 3D Globe Plans</title>
  <meta name="description" content="Pick a region from the right. The globe spins and a floating plan tile shows Lite, Premium, Pro and covered countries." />
  <style>
    :root{
      --bg:#0A0A0A;
      --card:#1A1A1A;
      --teal:#00A99D;
      --orange:#FF6B35;
      --text:#EDEDED;
      --muted:#a1a1aa;
      --ring:#2f2f2f;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{ margin:0; background:var(--bg); color:var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji"; overflow:hidden; }
    a{color:inherit; text-decoration:none}

    /* Splash screen */
    .splash{position:fixed; inset:0; z-index:100; display:grid; place-items:center; background:radial-gradient(1200px 600px at 50% -120px, rgba(255,107,53,.12), transparent), #0A0A0A; transition:opacity .6s ease}
    .splash.hide{opacity:0; pointer-events:none}
    .splash .brand{position:relative; display:flex; flex-direction:column; align-items:center; gap:14px; text-align:center; padding:24px 16px}
    .splash .logo{line-height:.86; filter:drop-shadow(0 18px 60px rgba(0,0,0,.55))}
    .splash .logo .dura{display:block; font-weight:1000; font-size:clamp(72px, 12vw, 180px); color:var(--orange); letter-spacing:-0.8px; text-shadow:0 12px 38px rgba(255,107,53,.22)}
    .splash .logo .sim{display:block; font-weight:1000; font-size:clamp(62px, 10.8vw, 160px); color:var(--teal); margin-left:14%; letter-spacing:-0.8px}
    .splash .tag{font-size:clamp(16px, 2.2vw, 24px); color:#e8e8e8; opacity:.95}
    .splash .shimmer{position:relative; width:min(62vw, 520px); height:10px; border-radius:999px; overflow:hidden; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.06)}
    .splash .shimmer::before{content:""; position:absolute; inset:-2px; background:linear-gradient(90deg, transparent, rgba(255,255,255,.28), transparent); transform:translateX(-100%); animation:sh 1.2s infinite ease}
    @keyframes sh{0%{transform:translateX(-100%)} 100%{transform:translateX(100%)} }
    .splash-map{position:absolute; inset:0; z-index:-1; opacity:.18; filter:blur(.4px);} 

    /* Layers */
    #three-stage{position:fixed; inset:0; z-index:0; background:radial-gradient(1200px 600px at 50% -100px, rgba(255,107,53,.08), transparent), #0A0A0A}
    #stars{position:fixed; inset:0; z-index:0; pointer-events:none}

    /* Header + Large Logo */
    .header{position:fixed; top:18px; left:18px; z-index:5; display:flex; flex-direction:column; align-items:flex-start; gap:12px; max-width:min(46vw, 600px)}
    .logo-stack{pointer-events:none; line-height:.9}
    .logo-stack .dura{display:block; font-weight:900; font-size:clamp(48px, 9vw, 132px); color:var(--orange); letter-spacing:-0.6px; text-shadow:0 10px 30px rgba(255,107,53,.15)}
    .logo-stack .sim{display:block; font-weight:900; font-size:clamp(42px, 8.2vw, 112px); color:var(--teal); margin-left:14%; letter-spacing:-0.6px}

    /* Menu tile (top-right) */
    .menu-tile{position:fixed; top:18px; right:18px; z-index:6; background:var(--teal); color:#0A0A0A; font-weight:900; border-radius:12px; padding:10px 14px; border:1px solid rgba(255,255,255,.08); box-shadow:0 10px 30px rgba(0,169,157,.22); cursor:pointer; backdrop-filter:blur(6px); transition:transform .2s ease, box-shadow .2s ease}
    .menu-tile:hover{transform:translateY(-1px); box-shadow:0 14px 36px rgba(0,169,157,.28)}

    /* Hotspots (globe markers) */
    .hotspot{position:fixed; z-index:3; width:18px; height:18px; border-radius:50%; background:var(--orange); box-shadow:0 0 16px rgba(255,107,53,.85), 0 0 30px rgba(255,107,53,.35) inset; transform:translate(-50%,-50%); pointer-events:auto; opacity:.95}
    .hotspot::after{content:""; position:absolute; inset:-8px; border-radius:inherit; border:1px solid rgba(255,107,53,.5); animation:pulse 1.8s infinite ease-out}
    @keyframes pulse{0%{transform:scale(0.9); opacity:.9} 70%{transform:scale(1.3); opacity:0} 100%{opacity:0}}

    /* Floating plan tile (centered) */
    .tile{position:fixed; z-index:4; min-width:280px; max-width:380px; background:rgba(26,26,26,.94); border:1px solid var(--ring); border-radius:16px; padding:12px; box-shadow:0 18px 56px rgba(0,0,0,.55); left:50%; top:50%; transform:translate(-50%,-50%) scale(.92); opacity:0; pointer-events:none; transition:opacity .22s ease, background .35s ease, box-shadow .35s ease; color:#fff}
    .tile.show{opacity:1; pointer-events:auto}
    .tile.appear{background:linear-gradient(180deg, rgba(255,107,53,.14), rgba(26,26,26,.94)); box-shadow:0 24px 80px rgba(255,107,53,.20), 0 18px 56px rgba(0,0,0,.55)}
    .tile h4{margin:0 0 4px 0; font-size:16px; color:var(--orange)}
    .tile .muted{color:#fff; font-size:12px}
    .tile .options{display:grid; gap:8px; margin-top:10px}
    .tile .opt{display:flex; align-items:center; justify-content:space-between; gap:10px; padding:10px 12px; border-radius:12px; background:#121212; border:1px solid #242424; cursor:pointer; transition:transform .18s ease, border-color .18s ease, background .18s ease}
    .tile .opt:hover{transform:translateY(-1px)}
    .tile .opt.sel{border-color:rgba(0,169,157,.6); background:#151515}
    .tile .label{font-weight:800; color:var(--orange)}
    .tile .label .gb{color:var(--teal)}
    .tile .price{color:#fff; font-weight:800}
    .tile .mini{font-size:11px; color:#fff; margin-top:8px}
    .tile .countries{display:flex; flex-wrap:wrap; gap:6px 8px; margin-top:10px}
    .tile .badge{font-size:11px; color:#fff; background:#151515; border:1px solid #2a2a2a; padding:4px 8px; border-radius:999px}
    .tile .add-people{margin-top:12px; padding:10px 12px; border-radius:12px; background:#101010; border:1px solid #242424}
    .tile .add-people .row{display:flex; align-items:center; justify-content:space-between; gap:10px}
    .tile .add-people label{font-size:13px; font-weight:800}
    .tile .add-people .fee{font-size:12px; color:var(--muted)}
    .tile .add-people input[type=range]{width:100%; accent-color:var(--teal)}
    .tile .add-people .tot{display:flex; align-items:center; justify-content:space-between; margin-top:6px; font-weight:800}
    .tile .add-people .tot .val{color:var(--orange)}

    /* Add-on title (left side) — moved below to avoid overlap */
    .addon{position:fixed; left:18px; bottom:120px; top:auto; transform:none; z-index:4; background:linear-gradient(90deg, rgba(0,169,157,.18), rgba(0,169,157,.06)); border:1px solid rgba(0,169,157,.25); color:#c8fffa; border-radius:14px; padding:12px 14px; min-width:260px; max-width:360px; filter:drop-shadow(0 10px 30px rgba(0,169,157,.15)); opacity:1}

    /* Region list (right) — larger tiles */
    .regions{position:fixed; right:14px; top:50%; transform:translateY(-50%); z-index:5; display:flex; flex-direction:column; gap:14px; width:min(44vw,320px)}
    .region{display:flex; align-items:center; justify-content:space-between; gap:14px; padding:16px 18px; border-radius:16px; background:rgba(255,255,255,.03); border:1px solid rgba(255,255,255,.08); cursor:pointer; transition:transform .18s ease, border-color .18s ease, background .18s ease}
    .region:hover{transform:translateY(-1px)}
    .region.sel{border-color:rgba(255,107,53,.7); background:rgba(255,107,53,.10)}
    .region .name{font-weight:900; font-size:18px}
    .region.sel .name{color:var(--orange)}
    .region .hint{font-size:14px; color:var(--muted)}

    /* Helper text under logo */
    .text-block{position:relative; z-index:4; max-width:48ch; opacity:0; transform:translateY(8px); transition:opacity .6s ease, transform .6s ease}
    .text-block.show{opacity:1; transform:none}
    .text-block .kicker{font-size:12px; color:var(--muted); margin-bottom:4px}
    .text-block .headline{font-size:20px; font-weight:800; line-height:1.1}
    .text-block .sub{font-size:13px; color:var(--muted); margin-top:6px}

    /* Scroll indicator */
    .scroll-ind{position:fixed; left:50%; bottom:18px; transform:translateX(-50%); z-index:4; opacity:1; transition:opacity .6s ease}
    .scroll-ind.hide{opacity:0}

    /* Referral strip */
    .ref-strip{position:fixed; left:0; right:0; bottom:0; z-index:6; background:var(--orange); color:#111; display:flex; align-items:center; justify-content:center; gap:12px; padding:10px 14px; font-weight:700; box-shadow:0 -10px 30px rgba(255,107,53,.2)}
    .ref-strip button{background:#111; color:#fff; border:none; padding:8px 12px; border-radius:10px; cursor:pointer}

    /* Share modal */
    .share{position:fixed; inset:0; z-index:20; display:grid; place-items:center; background:rgba(0,0,0,.6); opacity:0; pointer-events:none; transition:opacity .2s ease}
    .share.open{opacity:1; pointer-events:auto}
    .sheet{background:#111; border:1px solid #2b2b2b; color:#fff; border-radius:16px; width:min(92vw, 520px); padding:18px; box-shadow:0 40px 120px rgba(0,0,0,.6)}
    .sheet .row{display:flex; gap:10px}
    .sheet input{flex:1; padding:10px 12px; border-radius:10px; border:1px solid #2b2b2b; background:#0f0f0f; color:#fff}
    .sheet button{padding:10px 12px; border-radius:10px; border:1px solid #2b2b2b; background:var(--orange); color:#111; font-weight:800; cursor:pointer}

    /* Overlay nav */
    .overlay{position:fixed; inset:0; z-index:10; background:rgba(0,0,0,.6); opacity:0; pointer-events:none; transition:opacity .2s ease}
    .overlay.open{opacity:1; pointer-events:auto}
    .drawer{position:absolute; top:0; right:0; height:100%; width:min(92vw, 420px); background:#0f0f0f; border-left:1px solid #2a2a2a; padding:18px; box-shadow:0 40px 120px rgba(0,0,0,.6)}
    .nav-links{display:flex; flex-direction:column; gap:10px}
    .nav-links a{padding:10px 12px; border-radius:10px; border:1px solid #2a2a2a; background:#111; color:#fff}

    /* Responsive */
    @media (max-width: 900px){
      .regions{right:14px; bottom:84px; top:auto; transform:none; flex-direction:row; overflow:auto; padding-bottom:6px; width:auto}
      .region{min-width:220px}
      .header{max-width:min(70vw, 560px)}
      .logo-stack .dura{font-size:clamp(40px, 9.6vw, 96px)}
      .logo-stack .sim{font-size:clamp(36px, 8.8vw, 88px)}
      .addon{left:14px; bottom:130px; max-width:70vw}
    }
    @media (max-width: 820px){
      .addon{left:14px; bottom:140px;} 
    }
  </style>
</head>
<body>
  <!-- Splash Screen -->
  <div id="splash" class="splash" role="dialog" aria-label="Loading DuraSim">
    <canvas id="splashMap" class="splash-map" aria-hidden="true"></canvas>
    <div class="brand">
      <div class="logo" aria-hidden="true">
        <span class="dura">Dura</span>
        <span class="sim">Sim</span>
      </div>
      <div class="tag">one plan multiple people, zero hassle</div>
      <div class="shimmer" aria-hidden="true"></div>
    </div>
  </div>

  <canvas id="stars" aria-hidden="true"></canvas>
  <div id="three-stage" aria-label="3D globe"></div>

  <!-- Header with large stacked logo and helper copy beneath -->
  <div class="header">
    <div class="logo-stack" aria-label="DuraSim brand">
      <span class="dura">Dura</span>
      <span class="sim">Sim</span>
    </div>
    <!-- Helper text under logo -->
    <div id="heroText" class="text-block">
      <div class="kicker">Group‑eSIM, simplified</div>
      <div class="headline">Pick a region on the right. We’ll spin you there.</div>
      <div class="sub">Buy now — invite friends later. One plan, multiple travelers, on your terms.</div>
    </div>
  </div>

  <!-- Top-right Menu tile -->
  <button id="menuTile" class="menu-tile" aria-label="Open navigation">Menu</button>

  <!-- Slide-in nav overlay -->
  <div id="navOverlay" class="overlay" aria-hidden="true">
    <div class="drawer">
      <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:10px">
        <div style="display:flex; align-items:center; gap:8px"><strong>DuraSim</strong></div>
        <button id="closeNav" class="menu-tile" style="position:static; padding:8px 12px; border-radius:10px; background:#111; color:#fff; border:1px solid #2a2a2a; box-shadow:none">Close</button>
      </div>
      <nav class="nav-links">
        <a href="#">How it Works</a>
        <a href="#">Pricing</a>
        <a href="#">Support</a>
        <a href="#">Partnerships</a>
        <a href="#">SDK</a>
      </nav>
    </div>
  </div>

  <!-- Hotspots (on globe) -->
  <div id="hs-asia" class="hotspot" title="Asia"></div>
  <div id="hs-europe" class="hotspot" title="Europe"></div>
  <div id="hs-americas" class="hotspot" title="Americas"></div>

  <!-- Floating plan tile (content updates per region) -->
  <div id="planTile" class="tile" role="dialog" aria-live="polite" aria-label="Plans">
    <div class="tile-inner">
      <h4 id="tileTitle">Asia</h4>
      <div class="muted">Pick a data plan — add people anytime</div>
      <div class="options">
        <div class="opt" data-plan="lite"><span class="label"><span class="pname">Lite</span> · <span class="gb">xxxGB</span></span><span class="price">£xxx</span></div>
        <div class="opt" data-plan="prem"><span class="label"><span class="pname">Premium</span> · <span class="gb">xxxGB</span></span><span class="price">£xxx</span></div>
        <div class="opt" data-plan="pro"><span class="label"><span class="pname">Pro</span> · <span class="gb">xxxGB</span></span><span class="price">£xxx</span></div>
      </div>
      <div class="countries" id="tileCountries"></div>
      <div class="mini" id="tileTag">Covers key destinations across APAC.</div>

      <!-- Add additional people slider -->
      <div class="add-people" aria-label="Add additional people">
        <div class="row">
          <label for="addCount">Add additional people</label>
          <span class="fee" id="feeCopy">£10 each</span>
        </div>
        <input id="addCount" type="range" min="0" max="10" step="1" value="0" />
        <div class="tot"><span><span id="addCountVal">0</span> added</span><span class="val" id="addTotal">+ £0</span></div>
      </div>
    </div>
  </div>

  <!-- Add-on title (left) -->
  <div id="addon" class="addon">Add additional people to your group plan. £10 each.</div>

  <!-- Regions (right, static) -->
  <div id="regions" class="regions" aria-label="Available regions">
    <div class="region" data-key="asia"><span class="name">Asia</span><span class="hint">APAC</span></div>
    <div class="region" data-key="europe"><span class="name">Europe</span><span class="hint">EU + UK</span></div>
    <div class="region" data-key="americas"><span class="name">Americas</span><span class="hint">NA + LATAM</span></div>
  </div>

  <!-- Scroll indicator -->
  <div id="scrollInd" class="scroll-ind" aria-hidden="true">
    <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="var(--orange)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
  </div>

  <!-- Referral strip -->
  <div class="ref-strip">
    <span>Traveling with friends? Earn £xxx credit per referral — Invite Friends</span>
    <button id="invite">Invite</button>
  </div>

  <!-- Share modal -->
  <div id="share" class="share" aria-hidden="true">
    <div class="sheet">
      <h3 style="margin:0 0 8px 0">Invite friends</h3>
      <p style="margin:0 0 10px 0; color:#c9c9c9">Share your link and earn £xxx credit per referral.</p>
      <div class="row">
        <input id="refLink" value="https://durasim.example/ref?code=YOUR-CODE" readonly />
        <button id="copy">Copy</button>
      </div>
    </div>
  </div>

  <!-- Three.js -->
  <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>

  <script>
  (function(){
    const log = (...args)=>console.log('[DEBUG]', ...args);

    // Stars
    const stars = document.getElementById('stars');
    const sctx = stars.getContext('2d');
    const STAR_COUNT = 180;
    const starField = Array.from({length:STAR_COUNT}, ()=>({ x: Math.random(), y: Math.random(), r: Math.random()*1.3 + .2, o: .3 + Math.random()*.7 }));

    // Three.js scene
    const stage = document.getElementById('three-stage');
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    stage.appendChild(renderer.domElement);

    const RADIUS = 1.4; // globe size (base)
    const globe = new THREE.Group();
    scene.add(globe);
    camera.position.set(0, 0.12, 3.2);

    // Lights — darker, night‑mode friendly
    const amb = new THREE.AmbientLight(0x3a3a3a, 0.6); scene.add(amb);
    const hemi = new THREE.HemisphereLight(0x0b1220, 0x22150f, 0.35); scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xfff3e0, 0.55); dir.position.set(5,3,5); scene.add(dir);

    // Earth base — slightly darkened
    const loader = new THREE.TextureLoader();
    const TEX_URL = 'https://unpkg.com/three@0.158.0/examples/textures/land_ocean_ice_cloud_2048.jpg';
    const earthGeo = new THREE.SphereGeometry(RADIUS, 96, 96);
    const earthMat = new THREE.MeshPhongMaterial({ shininess: 6, color: 0x9a9a9a });
    const earth = new THREE.Mesh(earthGeo, earthMat); globe.add(earth);

    // Atmosphere rim
    const atmoGeo = new THREE.SphereGeometry(RADIUS*1.03, 64, 64);
    const atmoMat = new THREE.MeshBasicMaterial({ color: 0x1aa39a, transparent:true, opacity:0.10, blending: THREE.AdditiveBlending });
    const atmo = new THREE.Mesh(atmoGeo, atmoMat); globe.add(atmo);

    // Region outline overlays (teal lines, orange glow when selected)
    const overlays = [];
    const OVERLAY_RADIUS = RADIUS*1.004;

    function uvFromLatLon(lat, lon){
      const u = (lon + 180) / 360;
      const v = 1 - (lat + 90) / 180;
      return {u, v};
    }

    function makeMaskTexture(polys){
      const w = 2048, h = 1024;
      const c = document.createElement('canvas');
      c.width = w; c.height = h; const ctx = c.getContext('2d');
      ctx.clearRect(0,0,w,h);
      ctx.strokeStyle = '#00A99D';
      ctx.lineWidth = 2.0; ctx.globalAlpha = 1.0;
      ctx.lineJoin = 'round'; ctx.lineCap = 'round';
      polys.forEach(poly=>{
        ctx.beginPath();
        poly.forEach((pt, i)=>{
          const uv = uvFromLatLon(pt[1], pt[0]);
          const x = uv.u * w; const y = uv.v * h;
          if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
        });
        ctx.stroke();
      });
      const tex = new THREE.CanvasTexture(c);
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.ClampToEdgeWrapping;
      tex.needsUpdate = true;
      return tex;
    }

    function createRegionOverlay({key, polys}){
      const mask = makeMaskTexture(polys);
      const geo = new THREE.SphereGeometry(OVERLAY_RADIUS, 96, 96);
      const uniforms = {
        uMask: { value: mask },
        uTeal: { value: new THREE.Color(0x00A99D) },
        uOrange: { value: new THREE.Color(0xFF6B35) },
        uSelLat: { value: 0.0 },
        uSelLon: { value: 0.0 },
        uSelected: { value: 0.0 },
        uPlanBoost: { value: 0.0 },
        uTealIntensity: { value: 0.85 },
        uOrangeIntensity: { value: 0.75 },
        uOrangeWidth: { value: 0.55 },
        uOpacity: { value: 0.9 }
      };
      const mat = new THREE.ShaderMaterial({
        uniforms,
        vertexShader: `
          varying vec2 vUv;
          varying vec3 vNormal;
          void main(){
            vUv = uv;
            vNormal = normalize(normalMatrix * normal);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
          }
        `,
        fragmentShader: `
          precision highp float;
          varying vec2 vUv;
          varying vec3 vNormal;
          uniform sampler2D uMask;
          uniform vec3 uTeal;
          uniform vec3 uOrange;
          uniform float uSelLat; // radians
          uniform float uSelLon; // radians
          uniform float uSelected;
          uniform float uPlanBoost;
          uniform float uTealIntensity;
          uniform float uOrangeIntensity;
          uniform float uOrangeWidth;
          uniform float uOpacity;

          vec3 dirFromLatLon(float lat, float lon){
            float cl = cos(lat);
            return normalize(vec3(cl*cos(lon), sin(lat), cl*sin(lon)));
          }

          void main(){
            float maskA = texture2D(uMask, vUv).a;
            vec3 col = uTeal * maskA * uTealIntensity;
            vec3 selDir = dirFromLatLon(uSelLat, uSelLon);
            float angle = acos(clamp(dot(normalize(vNormal), selDir), -1.0, 1.0));
            float glow = exp(-pow(angle / uOrangeWidth, 2.0));
            col += uOrange * glow * maskA * uOrangeIntensity * (0.6 + uPlanBoost) * uSelected;
            gl_FragColor = vec4(col, uOpacity * clamp(maskA * (0.6 + glow*0.8*uSelected), 0.0, 1.0));
          }
        `,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        transparent: true
      });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.userData = { key, uniforms };
      globe.add(mesh);
      overlays.push(mesh);
    }

    // Rough region polygons (lon, lat)
    const polysEurope = [[[-10,35],[40,35],[40,70],[-10,70],[-10,35]]];
    const polysSEA = [[[95,-10],[140,-10],[140,25],[95,25],[95,-10]]];
    const polysAmericas = [[[-170,-60],[-30,-60],[-30,70],[-170,70],[-170,-60]]];

    createRegionOverlay({ key:'europe', polys: polysEurope });
    createRegionOverlay({ key:'asia', polys: polysSEA });
    createRegionOverlay({ key:'americas', polys: polysAmericas });

    // Regions
    const regions = [
      { key:'asia',     name:'Southeast Asia', lat:  7.0, lon: 110.0, tag:'Covers key destinations across SE Asia.', countries:['Singapore','Thailand','Vietnam','Malaysia','Indonesia','Philippines','Cambodia','Laos'] },
      { key:'europe',   name:'Europe',         lat: 54.0, lon:  15.0, tag:'Works across the EU and UK.', countries:['United Kingdom','Germany','France','Spain','Italy','Netherlands','Sweden','Portugal'] },
      { key:'americas', name:'Americas',       lat: 15.0, lon: -80.0, tag:'From Canada to Argentina.', countries:['United States','Canada','Mexico','Brazil','Argentina','Chile','Peru','Colombia'] }
    ];

    function yawPitchFor(lat,lon){
      const toRad = Math.PI/180;
      const yaw = -lon*toRad;
      const pitch = lat*toRad;
      return { yaw, pitch: -pitch*0.5 };
    }

    // Rotation targets
    const STEP = 30 * Math.PI/180;
    let targetYaw = yawPitchFor(regions[0].lat, regions[0].lon).yaw;
    let targetPitch = yawPitchFor(regions[0].lat, regions[0].lon).pitch;
    let yaw = targetYaw; let pitch = targetPitch;
    let regionIndex = 0;

    // UI refs
    const tile = document.getElementById('planTile');
    const tileTitle = document.getElementById('tileTitle');
    const tileTag = document.getElementById('tileTag');
    const tileCountries = document.getElementById('tileCountries');
    const addon = document.getElementById('addon');
    const splash = document.getElementById('splash');
    const splashMap = document.getElementById('splashMap');
    const smctx = splashMap.getContext('2d');

    // Add-people slider logic
    const ADDON_FEE = 10; // £ per additional person
    const addCountEl = document.getElementById('addCount');
    const addCountVal = document.getElementById('addCountVal');
    const addTotal = document.getElementById('addTotal');
    const feeCopy = document.getElementById('feeCopy');
    function updateAddPeople(){
      const n = parseInt(addCountEl.value, 10) || 0;
      addCountVal.textContent = n;
      addTotal.textContent = `+ £${n*ADDON_FEE}`;
      feeCopy.textContent = `£${ADDON_FEE} each`;
    }

    // Floating tile behavior — center of viewport
    let tileScale = 0.92, targetScale = 1.0;

    // Plan boost for glow
    let planBoost = 0.0;

    function updateTileFor(key){
      const r = regions.find(x=>x.key===key); if(!r) return;
      tileTitle.textContent = r.name;
      tileTag.textContent = r.tag;
      tileCountries.innerHTML = '';
      r.countries.forEach(c=>{
        const span = document.createElement('span');
        span.className = 'badge'; span.textContent = c; tileCountries.appendChild(span);
      });
      tile.querySelectorAll('.opt').forEach(o=>o.classList.remove('sel'));
    }

    function showTileWithHue(){
      tile.classList.add('show','appear');
      tileScale = 0.92; targetScale = 1.0;
      clearTimeout(showTileWithHue._t);
      showTileWithHue._t = setTimeout(()=> tile.classList.remove('appear'), 650);
    }

    function updateOverlaySelection(selKey){
      const r = regions.find(x=>x.key===selKey); if(!r) return;
      overlays.forEach(m=>{
        const u = m.userData.uniforms;
        u.uSelLat.value = r.lat * Math.PI/180;
        u.uSelLon.value = r.lon * Math.PI/180;
        u.uSelected.value = (m.userData.key === selKey) ? 1.0 : 0.0;
      });
    }

    function focusRegion(key){
      const r = regions.find(x=>x.key===key);
      if(!r) return;
      const t = yawPitchFor(r.lat, r.lon);
      targetYaw = Math.round(t.yaw/STEP)*STEP;
      targetPitch = t.pitch;
      regionIndex = regions.findIndex(x=>x.key===key);
      updateTileFor(key);
      setSelectedRegionChip(key);
      showTileWithHue();
      addon.classList.add('show');
      updateOverlaySelection(key);
      log('focus', key);
    }

    // Project lat/lon to screen
    const tmp = new THREE.Vector3();
    function projectLatLon(lat,lon){
      const toRad = Math.PI/180; const phi = (90-lat)*toRad; const theta = (lon+180)*toRad;
      const r = RADIUS*1.01;
      const x = -r * Math.sin(phi) * Math.cos(theta);
      const z =  r * Math.sin(phi) * Math.sin(theta);
      const y =  r * Math.cos(phi);
      tmp.set(x,y,z);
      tmp.applyAxisAngle(new THREE.Vector3(1,0,0), pitch);
      tmp.applyAxisAngle(new THREE.Vector3(0,1,0), yaw);
      tmp.project(camera);
      return {
        x: (tmp.x * 0.5 + 0.5) * renderer.domElement.clientWidth,
        y: (-tmp.y * 0.5 + 0.5) * renderer.domElement.clientHeight,
        visible: tmp.z < 1
      };
    }

    // Hotspots
    const hs = {
      asia: document.getElementById('hs-asia'),
      europe: document.getElementById('hs-europe'),
      americas: document.getElementById('hs-americas')
    };
    function placeHotspots(){
      regions.forEach(r=>{
        const p = projectLatLon(r.lat, r.lon);
        const el = hs[r.key];
        el.style.left = p.x+'px'; el.style.top = p.y+'px'; el.style.opacity = p.visible ? 1 : 0.2;
      });
    }

    // Plan selection inside tile
    tile.querySelectorAll('.opt').forEach(opt=>{
      opt.addEventListener('click', ()=>{
        tile.querySelectorAll('.opt').forEach(o=>o.classList.remove('sel'));
        opt.classList.add('sel');
        const region = regions[regionIndex].key;
        planBoost = 0.7; // spike glow briefly
        log('plan-select', {region, plan: opt.dataset.plan});
      });
    });

    // Add-people slider events
    addCountEl.addEventListener('input', updateAddPeople);
    updateAddPeople();

    // Region list interactions (right)
    const regionEls = Array.from(document.querySelectorAll('.region'));
    function setSelectedRegionChip(key){
      regionEls.forEach(el=> el.classList.toggle('sel', el.dataset.key===key));
    }
    regionEls.forEach(el=>{
      el.addEventListener('click', ()=>{ focusRegion(el.dataset.key); });
    });

    // Hotspot clicks focus region
    Object.entries(hs).forEach(([key,el])=>{
      el.addEventListener('click', ()=>{ focusRegion(key); });
    });

    // Stars + renderer sizing
    function drawStars(t){
      const w = stars.width, h = stars.height;
      sctx.clearRect(0,0,w,h);
      sctx.save();
      for(const s of starField){
        const tw = 0.3 + Math.sin((t*0.001) + s.x*10 + s.y*7)*0.2;
        sctx.globalAlpha = s.o * (0.75 + tw*0.25);
        sctx.fillStyle = '#ffffff';
        sctx.beginPath();
        sctx.arc(s.x*w, s.y*h, s.r, 0, Math.PI*2);
        sctx.fill();
      }
      sctx.restore();
    }

    // Splash map canvas sizing + draw
    function sizeSplash(){
      const w = window.innerWidth, h = window.innerHeight;
      splashMap.width = w * devicePixelRatio; 
      splashMap.height = h * devicePixelRatio; 
      splashMap.style.width = w + 'px';
      splashMap.style.height = h + 'px';
      smctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
      drawSplashMap();
    }

    function drawSplashMap(){
      const w = splashMap.width / devicePixelRatio; const h = splashMap.height / devicePixelRatio;
      smctx.clearRect(0,0,w,h);
      smctx.lineWidth = 1.0; smctx.strokeStyle = 'rgba(255,107,53,0.45)';
      const step = 15; 
      for(let lon=-180; lon<=180; lon+=step){
        const x = (lon + 180) / 360 * w;
        smctx.beginPath(); smctx.moveTo(x, 0); smctx.lineTo(x, h); smctx.stroke();
      }
      for(let lat=-75; lat<=75; lat+=step){
        const y = (1 - (lat + 90) / 180) * h;
        smctx.beginPath(); smctx.moveTo(0, y); smctx.lineTo(w, y); smctx.stroke();
      }
      smctx.lineWidth = 1.6; smctx.strokeStyle = 'rgba(255,107,53,0.55)';
      const x0 = (0 + 180) / 360 * w; const y0 = (1 - (0 + 90) / 180) * h;
      smctx.beginPath(); smctx.moveTo(x0, 0); smctx.lineTo(x0, h); smctx.stroke();
      smctx.beginPath(); smctx.moveTo(0, y0); smctx.lineTo(w, y0); smctx.stroke();
    }

    // Resize
    function fitCameraToSphere(radius){
      const fov = camera.fov * Math.PI/180;
      const dist = radius / Math.sin(fov/2); // perfect fit
      camera.position.z = dist * 0.95; // closer to make globe ~20% larger on screen
    }

    function resize(){
      const w = window.innerWidth, h = window.innerHeight;
      stars.width = w; stars.height = h;
      renderer.setSize(w, h, false);
      camera.aspect = w/h; camera.updateProjectionMatrix();
      fitCameraToSphere(RADIUS);
      drawStars(0);
      sizeSplash();
    }

    // Splash dismissal controller
    const splashStart = performance.now();
    const MIN_SPLASH_MS = 700;
    let splashDone = false;
    function dismissSplash(){
      if (splashDone) return; splashDone = true;
      const elapsed = performance.now() - splashStart;
      const wait = Math.max(0, MIN_SPLASH_MS - elapsed);
      setTimeout(()=>{
        splash.classList.add('hide');
        setTimeout(()=>{
          splash.remove();
          document.getElementById('heroText').classList.add('show');
          setTimeout(()=>addon.classList.add('show'), 400);
        }, 650);
      }, wait);
    }

    // Tiny planes flying periodically
    const planeGroup = new THREE.Group();
    globe.add(planeGroup);

    function makeTinyPlane(){
      // Slightly larger + brighter for visibility
      const gBody = new THREE.ConeGeometry(0.04, 0.16, 16);
      const mBody = new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.15, roughness: 0.25, emissive: 0x1a1a1a, emissiveIntensity: 0.9 });
      const body = new THREE.Mesh(gBody, mBody); body.rotation.x = Math.PI/2;
      const gWing = new THREE.BoxGeometry(0.10, 0.012, 0.026);
      const mWing = new THREE.MeshStandardMaterial({ color: 0x00A99D, emissive: 0x00665d, emissiveIntensity: 1.2 });
      const wing = new THREE.Mesh(gWing, mWing); wing.position.set(0,0,0);
      const tail = new THREE.Mesh(new THREE.BoxGeometry(0.024, 0.038, 0.012), new THREE.MeshStandardMaterial({ color: 0xFF6B35, emissive: 0x5a2612, emissiveIntensity: 1.5 }));
      tail.position.set(0, -0.06, 0.0);
      const p = new THREE.Group();
      p.add(body); p.add(wing); p.add(tail);
      return p;
    }

    function randLatLon(){
      const lat = (Math.random()*120 - 60);
      const lon = (Math.random()*360 - 180);
      return {lat, lon};
    }

    function vecFromLatLon(lat, lon){
      const toRad = Math.PI/180; const phi = (90-lat)*toRad; const theta = (lon+180)*toRad;
      const x = -Math.sin(phi) * Math.cos(theta);
      const z =  Math.sin(phi) * Math.sin(theta);
      const y =  Math.cos(phi);
      return new THREE.Vector3(x,y,z).normalize();
    }

    const planes = [];
    const PLANE_ALT = RADIUS * 1.12; // slightly higher for clear separation above atmosphere

    function spawnPlane(){
      const a = randLatLon();
      const b = randLatLon();
      const va = vecFromLatLon(a.lat, a.lon);
      const vb = vecFromLatLon(b.lat, b.lon);
      const plane = makeTinyPlane();
      planeGroup.add(plane);
      planes.push({ mesh: plane, a: va, b: vb, t: 0, speed: 0.001 + Math.random()*0.0012 });
    }

    function updatePlanes(dt){
      for(let i=planes.length-1;i>=0;i--){
        const p = planes[i];
        p.t += p.speed * dt;
        if(p.t >= 1){
          planeGroup.remove(p.mesh);
          planes.splice(i,1);
          continue;
        }
        const v = new THREE.Vector3().copy(p.a).slerp(p.b, p.t).normalize();
        const pos = v.clone().multiplyScalar(PLANE_ALT);
        p.mesh.position.copy(pos);
        const vNext = new THREE.Vector3().copy(p.a).slerp(p.b, Math.min(1, p.t+0.01)).normalize();
        const posNext = vNext.clone().multiplyScalar(PLANE_ALT);
        p.mesh.lookAt(posNext);
      }
      // Keep a healthy stream of planes
      if(planes.length < 6 && Math.random() < 0.03){
        spawnPlane();
      }
    }

    // Animation loop
    let last = performance.now();
    function animate(t){
      requestAnimationFrame(animate);
      const now = performance.now();
      const dt = Math.min(60, now - last); last = now;

      const k = 0.06;
      yaw += (targetYaw - yaw) * k;
      pitch += (targetPitch - pitch) * k;
      pitch = Math.max(-0.8, Math.min(0.8, pitch));
      globe.rotation.set(pitch, yaw, 0);

      earth.rotation.y += 0.0007;

      planBoost *= 0.93;
      overlays.forEach(m=>{ m.userData.uniforms.uPlanBoost.value = planBoost; });

      placeHotspots();

      tileScale += (targetScale - tileScale) * 0.08;
      tile.style.transform = `translate(-50%,-50%) scale(${tileScale.toFixed(3)})`;

      drawStars(t || 0);

      updatePlanes(dt);

      renderer.render(scene, camera);
    }

    // Init
    function init(){
      window.addEventListener('resize', resize);
      resize();
      focusRegion('asia');
      for(let i=0;i<4;i++) spawnPlane();
      animate(0);
    }

    // Load earth texture and then dismiss splash when ready
    const earthTexOnLoad = (tex)=>{ earthMat.map = tex; earthMat.needsUpdate = true; log('tex','loaded'); dismissSplash(); };
    const earthTexOnErr = (err)=>{ console.warn('Texture load failed; proceeding sans map', err); dismissSplash(); };
    loader.load(TEX_URL, earthTexOnLoad, undefined, earthTexOnErr);

    init();
  })();
  </script>
</body>
</html>
